\section{NP Membership of the Minecraft Water Problem}
In this chapter, we want to show that our language is a member of the problem class NP. If a short certificate exists and the verifier accepts in polynomial time, the language is complete. If the verifier also rejects assignments not part of the language, we call it sound. Only if our language is complete and sound it is a member of NP, therefore we need to find a short certificate and a verifier, which accepts or rejects the assignment in polynomial runtime.

\paragraph{Tick Logic}
Now we want to show that only a polynomial number of ticks possible. The Minecraft world consists of n = x\_range * y\_range * z\_range blocks. One tick is a transition from one valid world state to another valid world state. In principle water can flow horizontally for a maximum distance of seven blocks in each direction. If the water flows down to a lower level, this maximum of seven blocks resets, and the water can flow for another seven blocks horizontally on the new level. Because our world is finite, the maximum flow path is constrained by the world borders. In the worst case the water flows from one border seven blocks before flowing downward, repeating this for every vertical level of the world. For simplicity we can estimate the maximum flow length in the following analysis as n, because trivially it cannot be bigger than n. Moreover, since the number of blocks is calculated as x\_range * y\_range * z\_range, where every range must be at least $\geq$ 1, y\_range is definitely $\leq$ n. This results in a maximum number of n * n ticks. The only variation is possible through the effect of tripwires. When water flows onto a block with tripwire, the interaction may cause sand blocks to fall down and trigger water to flow again from the maximum y\_range. Thus, our worst-case number of ticks becomes n * n * t, where t describes the number of tripwires. Additionally, at maximum one tripwire can be placed on every block, therefore, t must be $\leq$ n. This results in a worst-case number of n * n * n ticks, which is in O(n³).

\paragraph{Checking of gold blocks}
Once there has been a tick with no updates, we can start checking the gold block. It is not possible that there exists a tick with updates after a tick with no updates. For this check we need to loop through the tape and look at every entry. If the current block is a gold block we look at the block above and check if this is a water block. In this loop we look at every entry, therefore the runtime is n. To check the existence of a water block above we need to go through the entire tape in the worst-case, resulting in a runtime of O(n²). If we discover that one gold block is not covered with water we can reject the assignment, thus if we get to the last entry of the tape without rejecting, we can accept the assignment. Therefore our verifier is complete and sound.


Now we have found a short certificate and a verifying Turing Machine, thus proving that our language is a member of NP. Finding an given assignment is much harder than verifying it, but is definitely solvable by brute-forcing in exponential time, hence part of EXP.
